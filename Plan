### **ğŸš€ Plan dÃ©taillÃ© des prochaines Ã©tapes pour finaliser "So Long"**
Maintenant que **MiniLibX est installÃ© et fonctionnel**, on peut avancer **par Ã©tapes bien dÃ©finies** pour coder ton jeu **So Long** proprement.

---

# **ğŸ“ Plan dÃ©taillÃ© des Ã©tapes restantes**
## **ğŸ“Œ Ã‰tape 1 : Gestion de la carte (Parsing & VÃ©rifications)**
ğŸ‘‰ **Objectif** : Lire une carte `.ber` et sâ€™assurer quâ€™elle est **valide**.

ğŸ”¹ **Fichiers concernÃ©s** :
- `map.c`
- `map_utils.c`

ğŸ”¹ **Ce qu'on va faire** :
âœ… Lire le fichier `.ber` et stocker la carte dans une structure.  
âœ… VÃ©rifier que la carte respecte ces rÃ¨gles :
   - **EntourÃ©e de murs** (`1` en bordure).
   - **Contient** un **joueur (P)**, une **sortie (E)**, et au moins un **collectible (C)**.
   - **Carte rectangulaire**.
   - **Un chemin jouable doit exister**.

ğŸ”¹ **Plan d'action :**
1. **Lire le fichier `.ber`** et stocker son contenu dans un tableau (`char **grid`).
2. **VÃ©rifier la validitÃ© de la carte** (prÃ©sence des Ã©lÃ©ments, murs autour...).
3. **Utiliser un algorithme `flood-fill`** pour s'assurer que la carte est jouable.

---

## **ğŸ“Œ Ã‰tape 2 : Initialisation du jeu**
ğŸ‘‰ **Objectif** : Charger la carte en mÃ©moire et **afficher une premiÃ¨re fenÃªtre** avec MiniLibX.

ğŸ”¹ **Fichiers concernÃ©s** :
- `main.c`
- `game.c`
- `render.c`

ğŸ”¹ **Ce qu'on va faire** :
âœ… Ouvrir une **fenÃªtre MiniLibX** (dimensions selon la carte).  
âœ… **Charger et afficher la carte** sous forme de sprites (murs, sol, joueur...).  

ğŸ”¹ **Plan d'action :**
1. **Initialiser MiniLibX (`mlx_init()`) et crÃ©er une fenÃªtre (`mlx_new_window()`)**.
2. **Charger les textures** (murs, sol, joueur, collectibles...).
3. **Afficher la carte** en fonction du contenu du fichier `.ber`.

---

## **ğŸ“Œ Ã‰tape 3 : Gestion des dÃ©placements**
ğŸ‘‰ **Objectif** : DÃ©placer le joueur **avec les touches WASD** et mettre Ã  jour l'affichage.

ğŸ”¹ **Fichiers concernÃ©s** :
- `player.c`
- `events.c`
- `game.c`

ğŸ”¹ **Ce qu'on va faire** :
âœ… GÃ©rer les **touches clavier (`WASD`)** pour dÃ©placer le joueur.  
âœ… **EmpÃªcher le joueur de passer Ã  travers les murs**.  
âœ… **Compter les dÃ©placements** et les afficher dans le terminal.  
âœ… **VÃ©rifier si tous les collectibles sont rÃ©cupÃ©rÃ©s** avant dâ€™autoriser la sortie.

ğŸ”¹ **Plan d'action :**
1. **Ajouter un event listener sur les touches (`mlx_key_hook()`)**.
2. **Mettre Ã  jour la position du joueur en fonction de la touche pressÃ©e**.
3. **VÃ©rifier si le joueur marche sur un collectible (`C`)** et le ramasser.
4. **Si tous les collectibles sont ramassÃ©s, autoriser la sortie (`E`)**.

---

## **ğŸ“Œ Ã‰tape 4 : Gestion des Ã©vÃ©nements (Quitter proprement)**
ğŸ‘‰ **Objectif** : Fermer proprement le jeu quand le joueur **appuie sur ESC** ou **ferme la fenÃªtre**.

ğŸ”¹ **Fichiers concernÃ©s** :
- `events.c`
- `free.c`

ğŸ”¹ **Ce qu'on va faire** :
âœ… Fermer proprement avec `ESC` (`mlx_destroy_window()`).  
âœ… Fermer en cliquant sur la croix de la fenÃªtre.  
âœ… LibÃ©rer toute la mÃ©moire (`free()` pour la carte, textures...).

ğŸ”¹ **Plan d'action :**
1. **Associer la touche `ESC` Ã  `mlx_key_hook()` pour quitter**.
2. **GÃ©rer la fermeture avec la croix (`mlx_hook()`)**.
3. **CrÃ©er une fonction `free_game()`** pour libÃ©rer mÃ©moire et fermer MiniLibX.

---

## **ğŸ“Œ Ã‰tape 5 : VÃ©rification et correction des bugs**
ğŸ‘‰ **Objectif** : Tester le jeu avec **plusieurs cartes** et corriger les bugs.

ğŸ”¹ **Ce qu'on va faire** :
âœ… Tester avec diffÃ©rentes tailles de cartes `.ber`.  
âœ… VÃ©rifier que le jeu **affiche bien une erreur** si la carte est invalide.  
âœ… VÃ©rifier que **le joueur ne passe pas Ã  travers les murs**.  
âœ… Sâ€™assurer que **la mÃ©moire est bien libÃ©rÃ©e** (`valgrind`).

ğŸ”¹ **Plan d'action :**
1. **Tester plusieurs cartes valides et invalides.**
2. **Corriger les bugs dÃ©tectÃ©s (ex: mauvais affichage, dÃ©placement incorrect).**
3. **VÃ©rifier la mÃ©moire avec `valgrind`** :
   ```sh
   valgrind --leak-check=full ./so_long maps/test.ber
   ```

---

## **ğŸ“Œ Ã‰tape 6 : Rendu final et push sur Git**
ğŸ‘‰ **Objectif** : Finaliser et rendre le projet.

ğŸ”¹ **Ce qu'on va faire** :
âœ… S'assurer que **tout respecte les rÃ¨gles** du sujet (norme, Makefile, fichiers propres).  
âœ… **VÃ©rifier le Makefile** pour qu'il compile bien sans relink.  
âœ… **Faire un dernier test global** pour vÃ©rifier que tout marche.  
âœ… **Pousser le projet sur Git**.

ğŸ”¹ **Plan d'action :**
1. **VÃ©rifier que tout compile bien :**
   ```sh
   make re
   ```
2. **Sâ€™assurer que le Makefile ne relink pas.**
3. **VÃ©rifier avec `norminette` que le code respecte la norme 42** :
   ```sh
   norminette */*.c */*.h
   ```
4. **Ajouter et commit sur Git :**
   ```sh
   git add .
   git commit -m "Final version of so_long"
   git push origin main
   ```

---

# **ğŸ¯ RÃ©capitulatif du plan global**
| Ã‰tape | Objectif | Fichiers |
|-------|----------|---------|
| **1** | Lire et vÃ©rifier la carte | `map.c`, `map_utils.c` |
| **2** | Afficher la carte dans une fenÃªtre MiniLibX | `main.c`, `game.c`, `render.c` |
| **3** | GÃ©rer les dÃ©placements du joueur | `player.c`, `events.c`, `game.c` |
| **4** | GÃ©rer les Ã©vÃ©nements (fermeture propre) | `events.c`, `free.c` |
| **5** | Tester, corriger les bugs | Tout le projet |
| **6** | Finaliser et rendre sur Git | Makefile, vÃ©rifications norme |

---

# **ğŸ“Œ Que faire maintenant ?**
Tu peux **commencer par lâ€™Ã©tape 1** : **Lire et vÃ©rifier la carte**.

âœ… **CrÃ©e un fichier `.ber` de test dans `maps/`** (exemple) :
```
111111
1P0C01
100001
1C0E01
111111
```
âœ… **Code `map.c` pour charger ce fichier et afficher son contenu.**  
Si tu veux que je tâ€™aide Ã  coder cette partie, **dis-moi** ! ğŸš€